# メモ

## まだ不明な部分

### 環境とは
dev, test, productionの違い（production用にpumaを設定したけど，これがどのような作用をしているのか）．

### flash
`application.html.erb`にflashを表示する部分を用意しておいて，適切なタイミング（redirectかrender？）を見計らってcontrollerでflashを記述します．

`flash`と`flash.now`で少々挙動が異なるよう．

## users_pathってなんだっけ？
`users_path`が何を表しているのか分からなくなったのでメモします．

名前付きルートの一覧（正確にはルート設定の一覧）を表示するコマンドがあるので，それで調べました．

`grep`で出力結果を絞ると見やすくなるよ

例）
```
$ rails rotues | grep users
```

調べてみたところ，`users_path`に紐づいているのは`user#create`でした．

`users#index`も同じルート名ですが，Verbが`POST`の場合は`users#create`に，`GET`の場合は`users#index`に自動的に切り替わるのかな？  
Rails賢い！！笑

## 補足説明（23）がよく分からない！！
以下の部分．

> 23. @current_userをnilに設定することが重要なのは、@current_userがdestroyアクションの直前に作成され、かつ、即座にリダイレクトしない場合だけです（サンプルアプリはどちらにも該当しません）。この2つのイベントが組み合わさる可能性は小さく、今作っているサンプルアプリでの対応は不要ですが、セキュリティに関連する処理なので、@current_user = nil行も含めた完全な形にしています。

#### つまりどういうことだ...？？
後半の部分については，何となく理解した（ようなしてないような）気がします．例えばあるwebアプリで，ユーザーがアカウント削除を行った時を考えると...（`@current_user = nil`の部分）

* アカウント削除→システムからそのユーザーデータが削除される
* 普通はここでリダイレクトしてログイン後の画面からログインが不要なページに移動させるけど...
* もしリダイレクトが行われなかった場合，システムはユーザーを依然としてログイン状態としてみなす
* ↑存在しないユーザーが存在している状態


## 結合テストが難しい...
たくさんやっていて，何をしているのか一体不明．．

なので言葉に起こしてみる！

`test 'login with valid information followed by logout'`を例にします．

1. テストアカウントを用いてログイン状態にする
    * `login_path`(=`sessions#create`)にリクエストを投げて，ログイン状態になったことを確認
    * ユーザーページにリダイレクト（`follow_redirect!`でcontrollerのredirect指示に従って遷移したかも確認）
1. ログイン状態で，本当にログインしているかどうかをページ要素の確認によって検証
1. ログアウトを行う
    * ログイン状態ではないことも確認
    * ログアウト後にログイン必須ページにいないことを確認
    * ページ要素の確認で検証